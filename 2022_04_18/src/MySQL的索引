数据库的索引:
为什么我们需要索引,比如一本书,它会有一个目录,这就相当于我们数据库中的索引.
当我们进行查找的时候,可以通过目录(索引)来快速的搜索,能大大提升查找效率.

当然,同理在数据中添加索引,虽然会大大提高数据的检索效率,但是 增删改 的操作就会 变慢,因为,如果我们需要更改一本书中的内容时,我们必须也要对目录进行同步
修改,这样目录索引和内容才是一对一匹配的.

跟数据的存储是一样的,索引也是要占空间的,如果一张表中的数据量过大,那么相对的 索引 所占的空间也会变大.

还有我们在生产环境中,如果一个数据库本身在创建的时候没有添加索引,在使用了一段时间之后,我们就不能贸然的添加索引.因为添加索引是一个很费时的事情.很可能将磁盘IO给占满.

同时,我们要知道 mysql 在进行查找的时候, 它不是在内存中进行遍历的,而是在磁盘上,那么我们知道内存中的访问速度是磁盘上的 3 - 4 个数量级.所以我们需要尽可能的减少访问磁盘
IO 的访问次数.

MySQL 中有关索引的具体操作(sql语句):

1. 查看一张表中的 索引:
show index from 表名;    (注意:primary key 和 unique 是自带索引的)

2. 给一张表中的某一列创建索引:
create index 索引名 on 表名(列名);

3. 从一张表中删除索引:
drop index 索引名 on 表名;     (删除索引 和 创建索引 一样,这是一件非常 低效 的操作.应避免使用)


---------------------------------------------------------------------------------------------------------

索引背后的数据结构:

在数据结构这门课中,我们学习了 顺序表/链表/堆/二叉搜索树/栈/哈希表等

那么 MySQL 中的数据结构是怎样的 ?
我们说在 数据库 中查找,要求是 速度要快/效率要高 ,那我们分析下上面的数据结构:

顺序表和链表:
这两种数据结构在查找这方面的效率都是 O(n),这里还要注意,在顺序表中 我们可以通过下标查找 ,这样的时间复杂度就是 O(1);而在 mysql 中的查找,我们说
的是查找一个 值,也就是我们并不会知道所谓的'下标';所以这两种的查找次数都是 O(n);每个元素都需要遍历一遍.

堆:
这种数据结构更是不合适,因为它只能给拿到 最大/最小 的元素.

栈:
栈在底层也使用数组,也就是 顺序表 或者 链表 实现的,同理不适合;

哈希表:
这个数据结构查找的效率很高,但还是一个原因,不能进行 '大于/小于' 这种范围查找;

二叉搜索树:
这种数据结构的查找方式 和 二分查找 很 相似,每次都可以去掉一半的数据,但是这只是理想情况下;现实的二叉搜索树的时间复杂度是 O(N),也就是每个元素都要遍历一遍.
这时 也就 变成了 一颗 单分支 的树.所以也不太适合.

总结了一下上面,好像 都不太适合,但我们发现 好像 还是 只有树形结构 才能满足 数据库 的查找.那 我们就可以从 二叉搜索树 上进行 思考.

由于 二叉搜索树 可能会出现 单分支 的情况.为了解决这种情况,我们 就可以 考虑 AVL数,这种树它在 二叉搜索树 的基础上,加了个条件:
左右子树的高度差不能 大于 1; 在这里,虽然解决了 极端情况 '单分支',但我们还是发现,如果这样 就卡的太死了,我们只是不希望出现 极端情况,而不是一定要求均分;

然后我们考虑到 红黑树 ,这种树 也是一种 平衡二叉树 , 但它 相比较 AVL 树 而言,要求则更加宽松.到这里,我们发现已经解决了上面的一些问题,但如果我们
仔细想想,就会发现还有 问题 :
如果当 数据 量非常大时 , 那么 我们的 这颗 红黑树 的高度就会 很 高 ,也就说明需要比价的次数 会 很高 ,从而使 磁盘IO 的次数也就变高.故而效率降低.

那么如何解决 当数据量 过大 时 ,这颗树的高度也不会太高,这里我们就可以用 n叉搜索树 ,也叫 B树 或者 B-树,这样就能解决这个问题了.

B树的数据结构:
二叉树的节点 都是一个 key 值,而 B 数的每个 根节点 中都有 多个 Key 值.而B树的子树,是根据父节点中 key 的个数来划分成一个一个的区间的,所分成的区间个数
为 key + 1 个.

这时我们解决了 数的高度 问题后,我们发现相比较于 二叉搜索树,B树的磁盘IO的次数确实边少了,效率也提高了.但这也只是相对来说,那我们能不能更叫高效了.

最合适的就是 B+树,它与B数的区别在于:
1. 查询的时候,速度较快.磁盘IO的次数较为稳定.
2. 父节点的 key 值 都会在 子节点中体现.
3. 由于父节点的 key 值会在 子节点 中体现,所以 数据的载荷都是放到 叶子节点上的 , 而非叶子节点 都指 单纯的 放了 一个 key 值,所以就会使非叶子节点
的数据量变小,很可能小到 在 缓存中就能进行比较,这样 磁盘 IO 的次数就基本上 没有了.效率也就高了不知道多少.
4. 由于B+树的叶子节点都会连接成一条链表,所以对于 范围的 查找 会变得更加简单合适.


